---
title: "[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교"
date: 2023-02-09T21:05:18+09:00
draft: false
tags: ["Javascript"]
categories: ["(book)모던 자바스크립트 Deep Dive"]
showToc: true
UseHugoToc: true
comments: true
---

# 1. 원시 값과 객체의 비교

## 0) 정리

- 자바스크립트의 데이터 타입
  - 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol
  - 객체 타입(object/reference type): 객체
- 원시 타입 vs. 객체 타입
  | | 원시 타입 | 객체 타입 |
  | ---------------------------------------------------------- | -------------- | ---------------- |
  | 변경가능한가? | immutable | mutable |
  | 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? | 실제 값 | 참조 값 |
  | 변수를 다른 변수에 할당할 때 전달 방법은? | 값에 의한 전달 | 참조에 의한 전달 |

## 1) 원시 값

- 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임.)
- 변수와 값
  - 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름임.
  - 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과임.
  - 원시 값은 변경불가능하다? → 원시 값 자체를 변경할 수 없음을 의미함.
- 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면
  → **새로운 메모리 공간**을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킴. 변수가 참조하던 메모리 공간의 주소가 바뀜.
  → 왜 메모리 공간의 주소가 바뀌는가?
  → 원시값의 불변성 때문임.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경하는 방법이 없음.

### 자바스크립트의 문자열

- 원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 정해야함. 원시 타입별로 메모리 공간의 크기가 미리 정해져 있음.
- 문자열의 경우는 길이에 따라 메모리 공간의 크기가 결정됨.
- 유사 배열 객체
  - 배열처럼 인덱스로 프로퍼티 접근 가능, length 프로퍼티를 갖는 객체임.

### 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 **변수의 원시 값이 복사되어 전달**됨.
- code
  ```jsx
  let score = 80;
  let copy = score;
  console.log(score === copy); //true
  ```
  - score와 copy 변수의 값은 **다른 메모리 공간에 저장된 별개의 값**임.
- code
  ```jsx
  ...
  //score값을 변경해도 copy 변수의 값에는 영향을 주지 않음.
  score = 100;
  console.log(score === copy); //false
  ```
- 엄격하게 표현하면 변수에는 값이 아니라 **메모리 주소가 전달**된다! (전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.)
  → 메모리 공간에 저장되어 있는 어떤 값을 식별할 수 있어야하므로 변수와 같은 식별자는 **메모리 주소**를 기억한다. (식별자는 메모리 주소에 붙인 이름이라고 할 수 있음.)

## 2) 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있음.
  → 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음.
- 원시 값은 상대적으로 적은 메모리를 소비한다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값보다 비용이 많이 든다.
- 자바스크립트의 객체 관리 방식
  - 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있음.
  - 클래스 기반 객체지향 언어(자바, C++)는 사전에 정의된 클래스를 기반으로 객체(인스턴스)생성함.
  - 자바스크립트는 클래스 없이 객체 생성 가능함.
  - 자바스크립트가 클래스 기반 객체지향 언어보다 객체 생성과 프로퍼티 접근의 비용이 더 많이 듦.
    - 해결법 → V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 히든 클래스 방식을 사용함.
- 참조값은 생성된 객체가 저장된 **메모리 공간의 주소**, 그 자체임.
  - 원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근함.
  - 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근함.
- 객체는 왜 변경 가능한 값으로 설계되어 있는가?
  - 메모리 사용의 효율성과 성능을 위해서임.
- 객체의 취약점
  - 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있음.

### 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨.
  → 참조에 의한 전달
- code

  ```
  const person = {
      name: "Lee",
  };
  //얕은 복사
  const copy = person;

  //copy를 통해 객체 변경
  copy.name = "slow";

  console.log(person); //{name: 'slow'}
  console.log(copy); //{name: 'slow'}
  ```

  - person, copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다.
    → 두 개의 식별자가 하나의 객체를 공유함.
    → 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음.

- **값에 의한 전달**과 **참조에 의한 전달**은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일함. → 자바스크립트에는 **값에 의한 전달**만 존재함.

## 참고 자료

- [[book] 모던 자바스크립트 Deep Dive, 이웅모](https://product.kyobobook.co.kr/detail/S000001766445)
