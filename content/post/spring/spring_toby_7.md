---
title: "[토비의 스프링 3.1] 6장 정리"
date: 2023-02-05T04:56:34+09:00
draft: false
tags: ["Spring", "Backend", "Java"]
categories: ["Spring"]
showToc: true
UseHugoToc: true
comments: true
---

## Intro

- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임.

## 단위 테스트

- 작은 단위의 테스트가 더 좋음.
  → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐.
- 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용
- 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
- 단위테스트 vs. 통합 테스트
  - 항상 단위테스트를 먼저 고려함.
  - 외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다.
  - 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임.
- 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임.

### 목 프레임워크

- 단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.)
- Mockito 프레임워크
  - 목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임.
  - mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드
- Mockito 사용 단계
  ```java
  @Test
  public void mockUpgradeLevels() throws Exception {
  	UserServiceImpl userServiceImpl = new UserServiceImpl();
  	//1) 인터페이스를 이용해 목 오브젝트 생성
  	UserDao mockUserDao = mock(UserDao.class);
  	//2) 목 오브젝트가 리턴할 값이 있으면 지정
  	//mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴
  	when(mockUserDao.getAll()).thenReturn(this.users);
  	//3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함.
  	userServiceImpl.setUserDao(mockUserDao);
  	...
  	//4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
  	//update() 메소드가 두 번 호출됐는지 확인
  	verify(mockUserDao, times(2)).update(any(User.class));
  	...
  }
  ```

## 다이내믹 프록시와 팩토리 빈

- 프록시 - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
  - 프록시의 특징은 타깃과 같은 인터페이스 구현 & 프록시가 타깃을 제어할 수 있는 위치에 있음
  - 사용목적에 따른 구분
    - 1. 클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴
    - 2. 타깃에 부가적인 기능 부여 → 데코레이터 패턴
- 타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트

### 데코레이터 패턴

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임.
  - 다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음.
- 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음.
- 프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦.
- 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임.

### 프록시 패턴

- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌.
- 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함.
- 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함.
- 구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.

### 다이내믹 프록시

- 다이내맥 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.
  - 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있으므.
- java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음.
- 프록시의 기능
  - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임
  - 지정된 요청에 대해서는 부가기능 수행
- 프록시 만들기가 번거로운 이유
  - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움.
    → JDK의 다이내믹 프록시로 해결
  - 부가기능 코드가 중복될 가능성이 있음.
- 리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임.
  - java.lang.reflect.Method 인터페이스
    - 메소드에 대한 자세한 정보를 담고 있음.
    - 특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌.

# 참고 자료

- [[book] **토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민**](https://product.kyobobook.co.kr/detail/S000000935358)
