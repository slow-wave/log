---
title: "[토비의 스프링 3.1] 6장 정리"
date: 2023-02-05T04:56:34+09:00
draft: false
tags: ["Spring", "Backend", "Java"]
categories: ["(book)토비의 스프링3.1"]
showToc: true
UseHugoToc: true
comments: true
---

## Intro

- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임.

## 단위 테스트

- 작은 단위의 테스트가 더 좋음.
  → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐.
- 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용
- 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
- 단위테스트 vs. 통합 테스트
  - 항상 단위테스트를 먼저 고려함.
  - 외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다.
  - 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임.
- 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임.

### 목 프레임워크

- 단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.)
- Mockito 프레임워크
  - 목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임.
  - mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드
- Mockito 사용 단계
  ```java
  @Test
  public void mockUpgradeLevels() throws Exception {
  	UserServiceImpl userServiceImpl = new UserServiceImpl();
  	//1) 인터페이스를 이용해 목 오브젝트 생성
  	UserDao mockUserDao = mock(UserDao.class);
  	//2) 목 오브젝트가 리턴할 값이 있으면 지정
  	//mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴
  	when(mockUserDao.getAll()).thenReturn(this.users);
  	//3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함.
  	userServiceImpl.setUserDao(mockUserDao);
  	...
  	//4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
  	//update() 메소드가 두 번 호출됐는지 확인
  	verify(mockUserDao, times(2)).update(any(User.class));
  	...
  }
  ```

## 다이내믹 프록시와 팩토리 빈

- 프록시 - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
  - 프록시의 특징은 타깃과 같은 인터페이스 구현 & 프록시가 타깃을 제어할 수 있는 위치에 있음
  - 사용목적에 따른 구분
    - 1. 클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴
    - 2. 타깃에 부가적인 기능 부여 → 데코레이터 패턴
- 타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트

### 데코레이터 패턴

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임.
  - 다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음.
- 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음.
- 프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦.
- 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임.

### 프록시 패턴

- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌.
- 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함.
- 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함.
- 구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.

### 다이내믹 프록시

- 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.
  - 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있음.
- java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음.
- 프록시의 기능
  - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임
  - 지정된 요청에 대해서는 부가기능 수행
- 프록시 만들기가 번거로운 이유
  - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움.
    → JDK의 다이내믹 프록시로 해결
  - 부가기능 코드가 중복될 가능성이 있음.
- 리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임.
  - java.lang.reflect.Method 인터페이스
    - 메소드에 대한 자세한 정보를 담고 있음.
    - 특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌.

### 팩토리 빈

- 팩토리 빈 - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈임.
- 스프링의 FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 됨.
- code(FactoryBean 인터페이스)
  ```java
  package org.springframework.beans.factory;

  public interface FactoryBean<T> {
  	T getObject() throws Exception; // 빈 오브젝트 생성해서 돌려주기
  	Class<? extends T> getObjectType(); //생성되는 오브젝트 타입 알려주기
  	boolean isSingleton(); //getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려주기
  }
  ```
- 프록시 팩토리 빈 방식의 장점 - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음.
  - DI가 중요한 역할을 함.
- 프록시 팩토리 빈의 한계
  - 프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일임. 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능함.
  - 하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어려움.
  - DI를 적용해 해결할 수 있을까?

## 스프링의 프록시 팩토리 빈

### ProxyFactoryBean

- 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈임.
  - TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있음.
- ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
  - MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받음.
  - 따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능함.

### ProxyFactoryBean의 특징

1. MethodInvocation

- 일종의 콜백 오브젝트임.
- proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있음.
- ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있음.

2. ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 **addAdvice()**라는 메소드를 사용함.

- ProxyFactoryBean 하나로 여러 개의 부가 기능을 제공해주는 프록시 만들 수 있음.
- advice - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트임.

3. 인터페이스 자동 검출 기능

- JDK 다이내믹 프록시의 경우 Hello 인터페이스를 통해 다이내믹 프록시 오브젝트의 타입을 결정함.
- 인터페이스를 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄.
- 타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이 있음.

### 포인트 컷

- 기존에 InvocationHandler를 직접 구현했을 때는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정하는 것이 있었음.
- 스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까?
  - 불가능함. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 됨.
  - 어떻게 해결할까?
    - MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남긴다. 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣음.
- 스프링의 ProxyFactoryBean 방식은 **부가기능(advice)과 메소드 선정 알고리즘(pointcut)**을 활용하는 유연한 구조 제공.
  - advice - 부가기능을 제공하는 오브젝트
  - pointcut - 메소드 선정 알고리즘을 담은 오브젝트
  - 어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용됨.
- 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조임.
- 어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)

### 어드바이스와 포인트컷의 재사용

- UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있음.
- 메소드의 선정을 위한 포인트 컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록하면 됨.

# 참고 자료

- [[book] **토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민**](https://product.kyobobook.co.kr/detail/S000000935358)
